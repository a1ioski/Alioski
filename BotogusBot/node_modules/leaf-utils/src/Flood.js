const Discord = require("discord.js");
const { disableButtons } = require("../functions");

module.exports = async (options) => {
    try {
        if (!options.message)
            throw new TypeError(
                "NO_MESSAGE: Please provide a message arguement"
            );
        if (typeof options.message !== "object")
            throw new TypeError(
                "INVALID_MESSAGE: Invalid Discord Message object was provided."
            );
        if (!options.slash_command) options.slash_command = false;
        if (typeof options.slash_command !== "boolean")
            throw new TypeError(
                "INVALID_COMMAND_TYPE: Slash command must be a boolean."
            );
        if (!options.difficulty) options.difficulty = 13;
        if (!options.time) options.time = 300000;
        if (parseInt(options.time) < 30000)
            throw new Error(
                "Leaf-utils: time argument must be greater than 30 Seconds (in ms)"
            );
        if (typeof options.time !== "number")
            throw new TypeError("Leaf-utils: time must be a number.");

        if (!options.embed) options.embed = {};
        if (!options.embed.title) options.embed.title = "Flood";
        if (!options.embed.color) options.embed.color = "RANDOM";

        if (!options.emojis) options.emojis = {};
        if (!options.emojis.redsquare) options.emojis.redsquare = "ðŸŸ¥";
        if (!options.emojis.bluesquare) options.emojis.bluesquare = "ðŸŸ¦";
        if (!options.emojis.yellowsquare) options.emojis.yellowsquare = "ðŸŸ¨";
        if (!options.emojis.greensquare) options.emojis.greensquare = "ðŸŸ©";
        if (!options.emojis.purplesquare) options.emojis.purplesquare = "ðŸŸª";
        if (!options.emojis.style) options.emojis.style = "PRIMARY";

        if (!options.authorOnly)
            options.authorOnly = "Only <@{{author}}> can use these buttons!";

        async function sendMessage(content) {
            if (options.slash_command)
                return options.message.editReply(content);
            else return options.message.channel.send(content);
        }

        if (options.slash_command) {
            if (!options.message.deferred) await options.message.deferReply();
            options.message.author = options.message.user;
        }

        const difficulty = options.difficulty;
        const _emojis = [
            options.emojis.redsquare,
            options.emojis.bluesquare,
            options.emojis.yellowsquare,
            options.emojis.greensquare,
            options.emojis.purplesquare,
        ];
        const emojis = _emojis.splice(0, Math.floor(difficulty / 2) - 1);

        let boardarray = [];
        const button = [];
        const queue = [
            {
                x: 0,
                y: 0,
            },
        ];

        let turn = 0;
        let guessed = 1;
        let lastColor;

        const row = new Discord.MessageActionRow();
        for (let i = 0; i < emojis.length; i++) {
            button[i] = new Discord.MessageButton()
                .setCustomId(emojis[i])
                .setLabel(" ")
                .setStyle(options.emojis.style)
                .setEmoji(emojis[i]);
            row.addComponents(button[i]);
        }

        for (let i = 0; i < difficulty; i++) {
            boardarray[i] = [];
            for (let j = 0; j < difficulty; j++) {
                boardarray[i][j] =
                    emojis[Math.floor(Math.random() * emojis.length)];
            }
        }

        boardarray[0][0] = "â¬œ";
        const gameEmbed = new Discord.MessageEmbed()
            .setTitle(options.embed.title)
            .setDescription(boardToString(boardarray))
            .setFooter({
                text: `Turns: ${turn}`,
            })
            .setColor(options.embed.color);

        const sent = await sendMessage({
            embeds: [gameEmbed],
            components: [row],
            fetchReply: true,
        });

        const collector = sent.createMessageComponentCollector({
            componentType: "BUTTON",
            time: options.time,
        });

        collector.on("collect", async (c) => {
            if (c.user.id !== options.message.author.id)
                return c.reply({
                    content: options.authorOnly.replace(
                        "{{author}}",
                        options.message.member.id
                    ),
                    ephemeral: true,
                });

            collector.resetTimer({
                time: options.time,
            });

            c.deferUpdate();

            if (
                queue.length === 1 &&
                boardarray[0][1] !== c.customId &&
                boardarray[1][0] !== c.customId
            )
                return;
            if (lastColor === c.customId) return;

            await checkAdjacents(c, queue, boardarray, difficulty);

            if (queue.length > guessed) {
                guessed = queue.length;
                turn++;
                lastColor = c.customId;
                queue.forEach((q) => {
                    boardarray[q.x][q.y] = c.customId;
                });
                gameEmbed.setDescription(boardToString(boardarray)).setFooter({
                    text: `Turns: ${turn}`,
                });
                sent.edit({
                    embeds: [gameEmbed],
                    components: [row],
                });
            }

            if (queue.length === difficulty ** 2) {
                collector.stop("won");
            }
        });

        collector.on("end", (collected, reason) => {
            if (reason === "won")
                gameEmbed.setAuthor({
                    name: options.message.author.username + " You win",
                    iconURL: options.message.author.displayAvatarURL(),
                });
            sent.edit({
                embeds: [gameEmbed],
                components: disableButtons(sent.components),
            });
        });
    } catch (e) {}
};

async function checkAdjacents(c, queue, boardarray, difficulty) {
    let i = 0;
    while (i < queue.length) {
        Up(queue[i].x, queue[i].y, c, queue, boardarray);
        Down(queue[i].x, queue[i].y, c, queue, boardarray, difficulty);
        Left(queue[i].x, queue[i].y, c, queue, boardarray);
        Right(queue[i].x, queue[i].y, c, queue, boardarray, difficulty);
        i++;
    }
}

async function Up(x, y, c, queue, boardarray) {
    if (queue.some((v) => v.x === x - 1 && v.y === y)) return;
    while (x > 0) {
        if (boardarray[x - 1][y] === c.customId) {
            if (!queue.some((v) => v.x === x - 1 && v.y === y))
                queue.push({
                    x: x - 1,
                    y: y,
                });
            x--;
        } else break;
    }
}

async function Down(x, y, c, queue, boardarray, difficulty) {
    if (queue.some((v) => v.x === x + 1 && v.y === y)) return;
    while (x < difficulty - 1) {
        if (boardarray[x + 1][y] === c.customId) {
            if (!queue.some((v) => v.x === x + 1 && v.y === y))
                queue.push({
                    x: x + 1,
                    y: y,
                });
            x++;
        } else break;
    }
}

async function Left(x, y, c, queue, boardarray) {
    if (queue.some((v) => v.x === x && v.y === y - 1)) return;
    while (y > 0) {
        if (boardarray[x][y - 1] === c.customId) {
            if (!queue.some((v) => v.x === x && v.y === y - 1))
                queue.push({
                    x: x,
                    y: y - 1,
                });
            y--;
        } else break;
    }
}

async function Right(x, y, c, queue, boardarray, difficulty) {
    if (queue.some((v) => v.x === x && v.y === y + 1)) return;
    while (y < difficulty - 1) {
        if (boardarray[x][y + 1] === c.customId) {
            if (!queue.some((v) => v.x === x && v.y === y + 1))
                queue.push({
                    x: x,
                    y: y + 1,
                });
            y++;
        } else break;
    }
}

function boardToString(board) {
    var string = "";
    for (var i = 0; i < board.length; i++) {
        string += `${board[i].join("")}`;
        if (i != board.length) string += "\n";
    }
    return string;
}
