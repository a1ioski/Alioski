const { MessageEmbed, MessageButton, MessageActionRow } = require("discord.js");
const { disableButtons } = require("../functions");
const fetch = require("node-fetch");

module.exports = async (options) => {
    if (!options.message)
        throw new TypeError("NO_MESSAGE: Please provide a message arguement");
    if (typeof options.message !== "object")
        throw new TypeError(
            "INVALID_MESSAGE: Invalid Discord Message object was provided."
        );
    if (!options.slash_command) options.slash_command = false;
    if (typeof options.slash_command !== "boolean")
        throw new TypeError(
            "INVALID_COMMAND_TYPE: Slash command must be a boolean."
        );
    if (!options.footer) options.footer = false;
    if (typeof options.footer !== "boolean")
        throw new TypeError("INVALID_COMMAND_TYPE: Footer must be a boolean.");
    if (!options.time) options.time = 300000;
    if (parseInt(options.time) < 30000)
        throw new Error(
            "Leaf-utils: time argument must be greater than 30 Seconds (in ms)"
        );
    if (typeof options.time !== "number")
        throw new TypeError("Leaf-utils: time must be a number.");

    if (!options.label) options.label = {};
    if (!options.label.firstlabel) options.label.firstlabel = "Next Meme";
    if (!options.label.secondlabel) options.label.secondlabel = "Stop";

    if (!options.emojis) options.emojis = {};
    if (!options.emojis.firstbutton) options.emojis.firstbutton = "↪️";
    if (!options.emojis.secondbutton) options.emojis.secondbutton = "🔴";

    if (!options.colors) options.colors = {};
    if (!options.colors.firstbutton) options.colors.firstbutton = "PRIMARY";
    if (!options.colors.secondbutton) options.colors.secondbutton = "DANGER";

    if (!options.embedColor) options.embedColor = "RANDOM";
    if (!options.authorOnly)
        options.authorOnly = "Only <@{{author}}> can use these buttons!";

    async function sendMessage(content) {
        if (options.slash_command) return options.message.editReply(content);
        else return options.message.channel.send(content);
    }

    if (options.slash_command) {
        if (!options.message.deferred) await options.message.deferReply();
        options.message.author = options.message.user;
    }

    let meme = await fetch("https://meme-api.herokuapp.com/gimme").then((r) =>
        r.json()
    );

    const row = new MessageActionRow().addComponents(
        new MessageButton()
            .setLabel(options.label.firstlabel)
            .setStyle(options.colors.firstbutton)
            .setCustomId("memerate")
            .setEmoji(options.emojis.firstbutton),

        new MessageButton()
            .setLabel(options.label.secondlabel)
            .setStyle(options.colors.secondbutton)
            .setCustomId("memeclose")
            .setEmoji(options.emojis.secondbutton)
    );

    const emb = new MessageEmbed()
        .setTitle(meme.title)
        .setURL(meme.postLink)
        .setImage(meme.url)
        .setColor(options.embedColor);
    if (options.footer) {
        emb.setFooter({
            text: `👍 ${meme.ups}`,
        });
    }

    const msg = await sendMessage({
        embeds: [emb],
        components: [row],
    });

    const collector = await msg.createMessageComponentCollector({
        type: "BUTTON",
        time: options.time,
    });

    collector.on("collect", async (i) => {
        if (i.user.id !== options.message.author.id)
            return i.reply({
                content: options.authorOnly.replace(
                    "{{author}}",
                    options.message.member.id
                ),
                ephemeral: true,
            });

        i.deferUpdate();

        if (i.customId === "memerate") {
            let meme2 = await fetch(
                "https://meme-api.herokuapp.com/gimme"
            ).then((r) => r.json());

            const emb2 = new MessageEmbed()
                .setTitle(meme2.title)
                .setURL(meme2.postLink)
                .setImage(meme2.url)
                .setColor(options.embedColor);
            if (options.footer) {
                emb2.setFooter({
                    text: `👍 ${meme2.ups}`,
                });
            }

            return msg.edit({
                embeds: [emb2],
            });
        }
        if (i.customId === "memeclose") {
            return msg.edit({
                components: disableButtons(msg.components),
            });
        }
    });

    collector.on("end", async (i, reason) => {
        if (reason === "time") {
            return msg.edit({
                components: disableButtons(msg.components),
            });
        }
    });
};
