const Discord = require("discord.js");
const fetch = require("node-fetch");

module.exports = async (options) => {
    if (!options.message)
        throw new TypeError("NO_MESSAGE: Please provide a message arguement");
    if (typeof options.message !== "object")
        throw new TypeError(
            "INVALID_MESSAGE: Invalid Discord Message object was provided."
        );
    if (!options.slash_command) options.slash_command = false;
    if (typeof options.slash_command !== "boolean")
        throw new TypeError(
            "INVALID_COMMAND_TYPE: Slash command must be a boolean."
        );
    if (!options.args)
        throw new Error("Leaf-utils: args argument was not specified.");
    if (!options.time) options.time = 300000;
    if (parseInt(options.time) < 30000)
        throw new Error(
            "Leaf-utils: time argument must be greater than 30 Seconds (in ms)"
        );
    if (typeof options.time !== "number")
        throw new TypeError("Leaf-utils: time must be a number.");

    if (!options.embed) options.embed = {};
    if (!options.embed.title)
        options.embed.title = "Successfully created a new emoji";
    if (!options.embed.description)
        options.embed.description = "click on these buttons to find emojis";
    if (!options.embed.color) options.embed.color = "RANDOM";

    if (!options.buttons) options.buttons = {};
    if (!options.buttons.back) options.buttons.back = "Back";
    if (!options.buttons.next) options.buttons.next = "Next";
    if (!options.buttons.add) options.buttons.add = "Add";

    if (!options.emojis) options.emojis = {};
    if (!options.emojis.back) options.emojis.back = null;
    if (!options.emojis.next) options.emojis.next = null;
    if (!options.emojis.add) options.emojis.add = null;

    if (!options.colors) options.colors = {};
    if (!options.colors.back) options.colors.back = "PRIMARY";
    if (!options.colors.next) options.colors.next = "PRIMARY";
    if (!options.colors.add) options.colors.dd = "DANGER";

    if (!options.noResultMessage)
        options.noResultMessage = "No results found for {{query}}";
    if (!options.errorMessage)
        options.errorMessage = "An error has occured. I can't add this emoji";
    if (!options.authorOnly)
        options.authorOnly = "Only <@{{author}}> can use these buttons!";

    async function sendMessage(content) {
        if (options.slash_command) return options.message.editReply(content);
        else return options.message.channel.send(content);
    }

    if (options.slash_command) {
        if (!options.message.deferred) await options.message.deferReply();
        options.message.author = options.message.user;
    }

    const args = options.args;
    let emojis = await fetch("https://emoji.gg/api/").then((res) => res.json());
    const q = args.join("");
    var matches = emojis.filter((s) => s.title == q || s.title.includes(q));

    matches = matches.filter((s) => s.filesize < 256e3);
    matches = matches.sort((a, b) => b.faves - a.faves);

    if (!matches.length) {
        return sendMessage({
            content: options.noResultMessage.replace("{{query}}", q),
        });
    }

    let page = 0;

    function embedUpdate(matches, page, success = false) {
        const embed = new Discord.MessageEmbed()
            .setTitle(matches[page].title)
            .setDescription(options.embed.description)
            .setURL("https://discordemoji.com/emoji/" + matches[page].slug)
            .setColor(options.embed.color)
            .setThumbnail(matches[page].image)
            .addField(
                `Animated`,
                `${matches[page].category == 8 ? "Yes" : "No"}`,
                true
            )
            .setFooter({
                text: `${page + 1} / ${matches.length}`,
            });
        if (success)
            embed.setAuthor({
                name: options.embed.title,
            });
        return embed;
    }

    const prevButton = new Discord.MessageButton()
        .setCustomId("previous")
        .setLabel(options.buttons.back)
        .setEmoji(options.emojis.back)
        .setStyle(options.colors.back)
        .setDisabled(true);
    const nextButton = new Discord.MessageButton()
        .setCustomId("next")
        .setLabel(options.buttons.next)
        .setEmoji(options.emojis.next)
        .setStyle(options.colors.next);
    const addButton = new Discord.MessageButton()
        .setCustomId("add")
        .setLabel(options.buttons.add)
        .setEmoji(options.emojis.add)
        .setStyle(options.colors.add);

    if (matches.length == 1) nextButton.setDisabled(true);

    let row = new Discord.MessageActionRow().addComponents(
        prevButton,
        nextButton,
        addButton
    );

    const sent = await sendMessage({
        embeds: [embedUpdate(matches, page)],
        components: [row],
    });

    const collector = sent.createMessageComponentCollector({
        componentType: "BUTTON",
        time: options.time,
    });

    collector.on("collect", (b) => {
        if (b.user.id !== options.message.author.id)
            return b.reply({
                content: options.authorOnly.replace(
                    "{{author}}",
                    options.message.member.id
                ),
                ephemeral: true,
            });

        b.deferUpdate();

        addButton.setDisabled(false);
        collector.resetTimer({
            time: options.time,
        });

        switch (b.customId) {
            case "previous":
                if (page === 0) return;
                else page--;
                if (page > 0) prevButton.setDisabled(false);
                else prevButton.setDisabled(true);
                nextButton.setDisabled(false);
                sent.edit({
                    embeds: [embedUpdate(matches, page)],
                    components: [row],
                });
                break;
            case "next":
                if (page === matches.length - 1) return;
                else page++;
                if (page < matches.length - 1) nextButton.setDisabled(false);
                else nextButton.setDisabled(true);
                prevButton.setDisabled(false);
                sent.edit({
                    embeds: [embedUpdate(matches, page)],
                    components: [row],
                });
                break;
            case "add":
                const res = matches[page];
                try {
                    options.message.guild.emojis.create(res.image, res.title);
                    addButton.setDisabled(true);
                    sent.edit({
                        ephemeral: true,
                        embeds: [embedUpdate(matches, page, true)],
                        components: [row],
                    });
                } catch (error) {
                    const errEmbed = new Discord.MessageEmbed()
                        .setColor(options.embed.color)
                        .setTitle(options.errorMessage);
                    sent.edit({
                        ephemeral: true,
                        embeds: [errEmbed],
                    });
                    collector.stop();
                }
                break;
        }
    });

    collector.on("end", (collection, reason) => {
        if (reason == "time")
            return sent.edit({
                components: [],
            });
    });
};
