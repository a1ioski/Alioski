const Discord = require("discord.js");
const currentGames = new Object();

module.exports = async (options) => {
    try {
        if (!options.message)
            throw new TypeError(
                "NO_MESSAGE: Please provide a message arguement"
            );
        if (typeof options.message !== "object")
            throw new TypeError(
                "INVALID_MESSAGE: Invalid Discord Message object was provided."
            );
        if (!options.slash_command) options.slash_command = false;
        if (typeof options.slash_command !== "boolean")
            throw new TypeError(
                "INVALID_COMMAND_TYPE: Slash command must be a boolean."
            );

        if (!options.embed) options.embed = {};
        if (!options.embed.title) options.embed.title = "Football Match";
        if (!options.embed.color) options.embed.color = "RANDOM";

        if (!options.buttons) options.buttons = {};
        if (!options.buttons.left) options.buttons.left = "Left";
        if (!options.buttons.middle) options.buttons.middle = "Middle";
        if (!options.buttons.right) options.buttons.right = "Right";

        if (!options.emojis) options.emojis = {};
        if (!options.emojis.goalkeeper) options.emojis.goalkeeper = "üßç‚Äç‚ôÇÔ∏è";
        if (!options.emojis.goal) options.emojis.goal = "ü•Ö";
        if (!options.emojis.soccer) options.emojis.soccer = "‚öΩ";

        if (!options.winMessage)
            options.winMessage =
                "GG, <@{{winner}}> scored in **{{time}} seconds**.";
        if (!options.loseMessage)
            options.loseMessage = "<@{{player}}> You lose";
        if (!options.ongoingMessage)
            options.ongoingMessage =
                "A game is already runnning in <#{{channel}}>. You cant start a new one";
        if (!options.authorOnly)
            options.authorOnly = "Only <@{{author}}> can use these buttons!";

        // errors
        if (typeof options.embed !== "object")
            throw new TypeError("Leaf-utils: embed must be an object.");
        if (typeof options.embed.title !== "string")
            throw new TypeError("Leaf-utils: embed title must be a string.");
        if (typeof options.buttons !== "object")
            throw new TypeError("Leaf-utils: buttons must be an object.");
        if (typeof options.buttons.left !== "string")
            throw new Error("Leaf-utils: left button text must be a string.");
        if (typeof options.buttons.middle !== "string")
            throw new Error("Leaf-utils: middle button text must be a string.");
        if (typeof options.buttons.right !== "string")
            throw new Error("Leaf-utils: right button text must be a string.");
        if (typeof options.emojis !== "object")
            throw new TypeError("Leaf-utils: emojis must be an object.");
        if (typeof options.emojis.goalkeeper !== "string")
            throw new TypeError("Leaf-utils: goalkeeper must be a string.");
        if (typeof options.emojis.goal !== "string")
            throw new TypeError("Leaf-utils: goal must be a string.");
        if (typeof options.emojis.soccer !== "string")
            throw new TypeError("Leaf-utils: soccer must be a string.");
        if (typeof options.winMessage !== "string")
            throw new TypeError("Leaf-utils: startMessage must be a string.");
        if (typeof options.loseMessage !== "string")
            throw new TypeError("Leaf-utils: loseMessage must be a string.");
        if (typeof options.ongoingMessage !== "string")
            throw new TypeError("Leaf-utils: ongoingMessage must be a string.");
        if (typeof options.authorOnly !== "string")
            throw new TypeError("Leaf-utils: authorOnly must be a string.");

        async function sendMessage(content) {
            if (options.slash_command)
                return options.message.editReply(content);
            else return options.message.channel.send(content);
        }

        if (options.slash_command) {
            if (!options.message.deferred) await options.message.deferReply();
            options.message.author = options.message.user;
        }

        if (currentGames[options.message.guild.id]) {
            const embed = new Discord.MessageEmbed()
                .setTitle(options.embed.title)
                .setColor(options.embed.color)
                .setDescription(
                    options.ongoingMessage.replace(
                        "{{channel}}",
                        currentGames[`${options.message.guild.id}_channel`]
                    )
                );
            return sendMessage({
                embeds: [embed],
            });
        }

        currentGames[options.message.guild.id] = true;
        currentGames[`${options.message.guild.id}_channel`] =
            options.message.channel.id;

        const positions = {
            left: `_ _                   ${options.emojis.goal}${options.emojis.goal}${options.emojis.goal}\n_ _                   ${options.emojis.goalkeeper}\n      \n_ _                         ${options.emojis.soccer}`,
            middle: `_ _                   ${options.emojis.goal}${options.emojis.goal}${options.emojis.goal}\n_ _                        ${options.emojis.goalkeeper}\n      \n_ _                         ${options.emojis.soccer}`,
            right: `_ _                   ${options.emojis.goal}${options.emojis.goal}${options.emojis.goal}\n_ _                              ${options.emojis.goalkeeper}\n      \n_ _                         ${options.emojis.soccer}`,
        };

        let randomized = Math.floor(
            Math.random() * Object.keys(positions).length
        );
        let gameEnded = false;
        let randomPos = positions[Object.keys(positions)[randomized]];

        const componentsArray = [
            {
                type: 1,
                components: [
                    {
                        type: 2,
                        style: "PRIMARY",
                        custom_id: "left",
                        label: options.buttons.left,
                    },
                    {
                        type: 2,
                        style: "DANGER",
                        custom_id: "middle",
                        label: options.buttons.middle,
                    },
                    {
                        type: 2,
                        style: "PRIMARY",
                        custom_id: "right",
                        label: options.buttons.right,
                    },
                ],
            },
        ];

        const msg = await sendMessage({
            content: randomPos,
            components: componentsArray,
        });

        function update() {
            randomized = Math.floor(
                Math.random() * Object.keys(positions).length
            );
            randomPos = positions[Object.keys(positions)[randomized]];

            msg.edit({
                content: randomPos,
                components: componentsArray,
            });
        }

        setInterval(() => {
            if (gameEnded == false) return update();
        }, 3000);

        const gameCreatedAt = Date.now();

        const filter = (button) => {
            if (button.user.id === options.message.author.id) return true;
            button.reply({
                content: options.authorOnly.replace(
                    "{{author}}",
                    options.message.member.id
                ),
                ephemeral: true,
            });
            return false;
        };

        const button = await msg.awaitMessageComponent({
            filter: filter,
            componentType: "BUTTON",
            max: 1,
        });

        await button.deferUpdate();

        if (button.customId !== Object.keys(positions)[randomized]) {
            gameEnded = true;
            btn = new Discord.MessageButton()
                .setStyle("PRIMARY")
                .setLabel(options.buttons.left)
                .setCustomId("left")
                .setDisabled();
            btn2 = new Discord.MessageButton()
                .setStyle("DANGER")
                .setLabel(options.buttons.middle)
                .setCustomId("middle")
                .setDisabled();
            btn3 = new Discord.MessageButton()
                .setStyle("PRIMARY")
                .setLabel(options.buttons.right)
                .setCustomId("right")
                .setDisabled();

            const _embed = new Discord.MessageEmbed()
                .setTitle(options.embed.title)
                .setDescription(
                    options.winMessage
                        .replace("{{winner}}", button.user.id)
                        .replace(
                            "{{time}}",
                            (Date.now() - gameCreatedAt) / 1000
                        )
                )
                .setColor(options.embed.color);

            await button.editReply({
                embeds: [_embed],
                components: [
                    {
                        type: 1,
                        components: [btn, btn2, btn3],
                    },
                ],
            });

            return delete currentGames[options.message.guild.id];
        } else {
            gameEnded = true;
            btn = new Discord.MessageButton()
                .setStyle("PRIMARY")
                .setLabel(options.buttons.left)
                .setCustomId("left")
                .setDisabled();
            btn2 = new Discord.MessageButton()
                .setStyle("DANGER")
                .setLabel(options.buttons.middle)
                .setCustomId("middle")
                .setDisabled();
            btn3 = new Discord.MessageButton()
                .setStyle("PRIMARY")
                .setLabel(options.buttons.right)
                .setCustomId("right")
                .setDisabled();

            const _embed = new Discord.MessageEmbed()
                .setTitle(options.embed.title)
                .setDescription(
                    options.loseMessage
                        .replace("{{player}}", button.user.id)
                        .replace(
                            "{{time}}",
                            (Date.now() - gameCreatedAt) / 1000
                        )
                )
                .setColor(options.embed.color);

            await button.editReply({
                embeds: [_embed],
                components: [
                    {
                        type: 1,
                        components: [btn, btn2, btn3],
                    },
                ],
            });

            return delete currentGames[options.message.guild.id];
        }
    } catch (err) {
        console.log(`Error Occured. | FootballMatch | Error: ${err.stack}`);
    }
};
