const Discord = require("discord.js");

module.exports = async (options) => {
    if (!options.message)
        throw new TypeError("NO_MESSAGE: Please provide a message arguement");
    if (typeof options.message !== "object")
        throw new TypeError(
            "INVALID_MESSAGE: Invalid Discord Message object was provided."
        );
    if (!options.slash_command) options.slash_command = false;
    if (typeof options.slash_command !== "boolean")
        throw new TypeError(
            "INVALID_COMMAND_TYPE: Slash command must be a boolean."
        );
    if (!options.time) options.time = 300000;
    if (parseInt(options.time) < 30000)
        throw new Error(
            "Leaf-utils: time argument must be greater than 30 Seconds (in ms)"
        );
    if (typeof options.time !== "number")
        throw new TypeError("Leaf-utils: time must be a number.");

    if (!options.embed) options.embed = {};
    if (!options.embed.title) options.embed.title = "Connect4";
    if (!options.embed.color) options.embed.color = "RANDOM";

    if (!options.challenge) options.challenge = {};
    if (!options.challenge.acceptButton)
        options.challenge.acceptButton = "Accept";
    if (!options.challenge.denyButton) options.challenge.denyButton = "Deny";

    if (!options.emojis) options.emojis = {};
    if (!options.emojis.player1) options.emojis.player1 = "🔴";
    if (!options.emojis.player2) options.emojis.player2 = "🟡";

    if (!options.noUser) options.noUser = "You must mention someone";
    if (!options.acceptMessage)
        options.acceptMessage = "{{player}} has challenged you {{opponent}}";
    if (!options.cancelMessage)
        options.cancelMessage =
            "{{opponent}} refused to have a fight with you!";
    if (!options.endMessage)
        options.endMessage = "Challenge not accepted in time";
    if (!options.timeoutMessage)
        options.timeoutMessage = "Game stopped due to inactivity";
    if (!options.authorOnly) options.authorOnly = "You can't use these buttons";

    // errors
    if (typeof options.time !== "number")
        throw new TypeError("Leaf-utils: time must be a number.");
    if (typeof options.challenge.acceptButton !== "string")
        throw new TypeError("accept button text must be a string.");
    if (typeof options.challenge.denyButton !== "string")
        throw new TypeError("deny button text must be a string.");
    if (typeof options.acceptMessage !== "string")
        throw new TypeError("acceptMessage must be a string.");
    if (typeof options.cancelMessage !== "string")
        throw new TypeError("cancelMessage must be a string.");

    async function sendMessage(content) {
        if (options.slash_command) return options.message.followUp(content);
        else return options.message.channel.send(content);
    }

    if (options.slash_command) {
        if (!options.message.deferred) await options.message.deferReply();
        options.message.author = options.message.user;
    }

    const p1 = options.message.member;
    const p2 = options.opponent;
    var turn = options.emojis.player1;
    var boardarray = [
        [`⚪`, `⚪`, `⚪`, `⚪`, `⚪`, `⚪`, `⚪`],
        [`⚪`, `⚪`, `⚪`, `⚪`, `⚪`, `⚪`, `⚪`],
        [`⚪`, `⚪`, `⚪`, `⚪`, `⚪`, `⚪`, `⚪`],
        [`⚪`, `⚪`, `⚪`, `⚪`, `⚪`, `⚪`, `⚪`],
        [`⚪`, `⚪`, `⚪`, `⚪`, `⚪`, `⚪`, `⚪`],
        [`⚪`, `⚪`, `⚪`, `⚪`, `⚪`, `⚪`, `⚪`],
        [`1️⃣`, `2️⃣`, `3️⃣`, `4️⃣`, `5️⃣`, `6️⃣`, `7️⃣`],
    ];

    if (!p2) return sendMessage(options.noUser);

    let yesButton = new Discord.MessageButton()
        .setStyle("SUCCESS")
        .setCustomId("yes_fc")
        .setLabel(options.challenge.acceptButton);

    let noButton = new Discord.MessageButton()
        .setStyle("DANGER")
        .setCustomId("no_fc")
        .setLabel(options.challenge.denyButton);

    const boardEmbed = new Discord.MessageEmbed()
        .setAuthor({
            name: `${p1.user.tag}'s Turn ${turn}`,
            iconURL: p1.displayAvatarURL(),
        })
        .setTitle(options.embed.title)
        .setDescription(boardToString(boardarray))
        .setColor(options.embed.color);

    let row = new Discord.MessageActionRow().addComponents([
        yesButton,
        noButton,
    ]);

    const confirmation = await sendMessage({
        embeds: [
            {
                title: options.embed.title,
                color: options.embed.color,
                description: options.acceptMessage
                    .replace("{{player}}", p1)
                    .replace("{{opponent}}", p2),
            },
        ],
        components: [row],
    });

    const confirmationCollector = confirmation.createMessageComponentCollector({
        componentType: "BUTTON",
        time: options.time,
    });

    confirmationCollector.on("collect", async (button) => {
        if (button.user.id !== p2.id) {
            return button.reply({
                content: options.authorOnly,
                ephemeral: true,
            });
        }

        if (button.customId === "yes_fc") {
            button.deferUpdate();
            yesButton.setDisabled();
            noButton = noButton
                .setStyle("DANGER")
                .setCustomId("no_fc")
                .setDisabled();

            row = new Discord.MessageActionRow().addComponents([
                yesButton,
                noButton,
            ]);

            confirmation
                .edit({
                    content: `${p2} accepted your challenge`,
                    embeds: [],
                    components: [row],
                })
                .then((reply) => {
                    setTimeout(() => {
                        reply.delete();
                    }, 5000);
                })
                .catch(() => {});

            const sent = await sendMessage({
                embeds: [boardEmbed],
            });

            const reactions = [`1️⃣`, `2️⃣`, `3️⃣`, `4️⃣`, `5️⃣`, `6️⃣`, `7️⃣`];
            for (const reaction of reactions) sent.react(reaction);

            const filter = (reaction, user) =>
                reactions.includes(reaction.emoji.name) &&
                !user.bot &&
                (user.id === p1.id || user.id === p2.id);

            const mainCollector = sent.createReactionCollector({
                filter,
                time: options.time,
            });

            mainCollector.on("collect", async (clicked) => {
                const reactionUser = clicked.users.cache
                    .filter((u) => u.id !== options.client.user.id)
                    .first();

                clicked.users.remove(reactionUser);

                if (
                    turn === options.emojis.player1 &&
                    reactionUser.id !== p1.id
                )
                    return;
                if (
                    turn === options.emojis.player2 &&
                    reactionUser.id !== p2.id
                )
                    return;

                if (reactions.includes(clicked.emoji.name))
                    mainCollector.resetTimer({
                        time: options.time,
                    });

                var x = 0;
                var y = 0;

                const emojiToNum = {
                    "1️⃣": 0,
                    "2️⃣": 1,
                    "3️⃣": 2,
                    "4️⃣": 3,
                    "5️⃣": 4,
                    "6️⃣": 5,
                    "7️⃣": 6,
                };

                x = emojiToNum[clicked.emoji.name];

                for (var y = 5; y >= 0; y--) {
                    if (boardarray[y][x] == "⚪") {
                        boardarray[y][x] = turn;
                        boardEmbed.setDescription(boardToString(boardarray));
                        break;
                    } else if (y == 0 && boardarray[y][x] != "⚪") return;
                }

                if (haswon(turn, boardarray, x, y) == true) {
                    mainCollector.stop("hasWon");
                    boardEmbed.setAuthor({
                        name: `${
                            turn === options.emojis.player1
                                ? p1.user.tag
                                : p2.tag
                        } WON`,
                        iconURL:
                            turn === options.emojis.player1
                                ? p1.displayAvatarURL()
                                : p2.displayAvatarURL(),
                    });

                    return sent.edit({
                        embeds: [boardEmbed],
                    });
                } else if (checkDraw(boardarray) == true) {
                    mainCollector.stop("draw");

                    boardEmbed.setAuthor({
                        name: "Draw!",
                    });

                    return sent.edit({
                        embeds: [boardEmbed],
                    });
                } else {
                    if (turn == options.emojis.player1) {
                        turn = options.emojis.player2;
                        boardEmbed.setAuthor({
                            name: `${p2.tag}'s Turn ${turn}`,
                            iconURL: p2.displayAvatarURL(),
                        });
                    } else {
                        turn = options.emojis.player1;
                        boardEmbed.setAuthor({
                            name: `${p1.user.tag}'s Turn ${turn}`,
                            iconURL: p1.displayAvatarURL(),
                        });
                    }
                }
                return sent.edit({
                    embeds: [boardEmbed],
                });
            });

            mainCollector.on("end", (collection, reason) => {
                sent.reactions.removeAll();
                if (reason == "time") {
                    boardEmbed.setAuthor({
                        name: options.timeoutMessage,
                    });
                    return sent.edit({
                        embeds: [boardEmbed],
                    });
                }
            });
        } else {
            button.deferUpdate();
            yesButton = yesButton
                .setStyle("SUCCESS")
                .setCustomId("yes_fc")
                .setDisabled();
            noButton.setDisabled();

            row = new Discord.MessageActionRow().addComponents([
                yesButton,
                noButton,
            ]);

            return confirmation
                .edit({
                    embeds: [
                        {
                            title: options.embed.title,
                            color: options.embed.color,
                            description: options.cancelMessage.replace(
                                "{{opponent}}",
                                p2
                            ),
                        },
                    ],
                    components: [row],
                })
                .then((reply) => {
                    setTimeout(() => {
                        reply.delete();
                    }, 10000);
                })
                .catch(() => {});
        }
    });

    confirmationCollector.on("end", async (button, reason) => {
        row.components[0].setDisabled(true);
        row.components[1].setDisabled(true);
        if (reason === "time") {
            confirmation.edit({
                content: options.endMessage,
                components: [row],
            });
        }
    });
};

function boardToString(board) {
    var string = "";
    for (var i = 0; i < board.length; i++) {
        string += `${board[i].join(" ")}`;
        if (i != board.length) string += "\n";
    }
    return string;
}

function checkDraw(boardarray) {
    if (
        boardarray[0][0] != "⚪" &&
        boardarray[0][1] != "⚪" &&
        boardarray[0][2] != "⚪" &&
        boardarray[0][3] != "⚪" &&
        boardarray[0][4] != "⚪" &&
        boardarray[0][5] != "⚪" &&
        boardarray[0][6] != "⚪"
    )
        return true;
    else return false;
}

function haswon(thisturn, boardarray, x, y) {
    for (var i = 0; i < 4; i++) {
        if (
            boardarray[y][i] == thisturn &&
            boardarray[y][i + 1] == thisturn &&
            boardarray[y][i + 2] == thisturn &&
            boardarray[y][i + 3] == thisturn
        )
            return true;
    }
    for (var i = 0; i < 3; i++) {
        if (
            boardarray[i][x] == thisturn &&
            boardarray[i + 1][x] == thisturn &&
            boardarray[i + 2][x] == thisturn &&
            boardarray[i + 3][x] == thisturn
        )
            return true;
    }
    for (var i = 0; i < 3; i++) {
        if (x < y) {
            if (x - x + i + 3 > 6 || y - x + i + 3 > 5) break;
        } else if (x - y + i + 3 > 6 || y - y + i + 3 > 5) break;
        if (
            boardarray[x < y ? y - x + i : y - y + i][
                x < y ? x - x + i : x - y + i
            ] == thisturn &&
            boardarray[x < y ? y - x + i + 1 : y - y + i + 1][
                x < y ? x - x + i + 1 : x - y + i + 1
            ] == thisturn &&
            boardarray[x < y ? y - x + i + 2 : y - y + i + 2][
                x < y ? x - x + i + 2 : x - y + i + 2
            ] == thisturn &&
            boardarray[x < y ? y - x + i + 3 : y - y + i + 3][
                x < y ? x - x + i + 3 : x - y + i + 3
            ] == thisturn
        )
            return true;
    }
    for (var i = 0; i < 3; i++) {
        if (x > 5 - y) {
            if (x - (5 - y) + i + 3 > 6 || y + (5 - y) - i - 3 < 0) break;
        } else if (x - x + i + 3 > 6 || y + x - i - 3 < 0) break;
        if (
            boardarray[x > 5 - y ? y + (5 - y) - i : y + x - i][
                x > 5 - y ? x - (5 - y) + i : x - x + i
            ] == thisturn &&
            boardarray[x > 5 - y ? y + (5 - y) - i - 1 : y + x - i - 1][
                x > 5 - y ? x - (5 - y) + i + 1 : x - x + i + 1
            ] == thisturn &&
            boardarray[x > 5 - y ? y + (5 - y) - i - 2 : y + x - i - 2][
                x > 5 - y ? x - (5 - y) + i + 2 : x - x + i + 2
            ] == thisturn &&
            boardarray[x > 5 - y ? y + (5 - y) - i - 3 : y + x - i - 3][
                x > 5 - y ? x - (5 - y) + i + 3 : x - x + i + 3
            ] == thisturn
        )
            return true;
    }
    return false;
}
