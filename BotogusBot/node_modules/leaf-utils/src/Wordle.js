const { MessageEmbed, MessageAttachment } = require("discord.js");
const Canvas = require("canvas");

const yellow = "#c9b458";
const green = "#6aaa64";
const gray = "#787c7e";

const offset = 10;
const offset2 = 5;
const radius = 8;

const rows = [
    ["Q", "W", "E", "R", "T", "Y", "U", "I", "O", "P"],
    ["A", "S", "D", "F", "G", "H", "J", "K", "L"],
    ["Z", "X", "C", "V", "B", "N", "M"],
];

module.exports = async (options) => {
    if (!options.message)
        throw new TypeError("NO_MESSAGE: Please provide a message arguement");
    if (typeof options.message !== "object")
        throw new TypeError(
            "INVALID_MESSAGE: Invalid Discord Message object was provided."
        );
    if (!options.slash_command) options.slash_command = false;
    if (typeof options.slash_command !== "boolean")
        throw new TypeError(
            "INVALID_COMMAND_TYPE: Slash command must be a boolean."
        );
    if (!options.time) options.time = 300000;
    if (typeof options.time !== "number")
        throw new TypeError("Leaf-utils: time must be a number.");

    if (!options.embed) options.embed = {};
    if (!options.embed.title) options.embed.title = "Wordle";
    if (!options.embed.color) options.embed.color = "RANDOM";

    if (!options.invalidMessage)
        options.invalidMessage = "This is not a valid word";
    if (!options.shortMessage)
        options.shortMessage =
            "The provided word does not contain 5 characters";
    if (!options.winMessage) options.winMessage = "GG, You win";
    if (!options.loseMessage)
        options.loseMessage = "Try again, the correct word was {{word}}";
    if (!options.timeoutMessage) options.timeoutMessage = "Time is up";

    // errors
    const wordle = options.wordle;
    if (!wordle)
        throw new TypeError("Leaf-utils: Please provide a wordle arguement");
    if (!Array.isArray(wordle))
        throw new TypeError("Leaf-utils: Words must be an array");
  if (wordle.length < 6) throw new TypeError('Leaf-utils: You must add at least 6 words');
  if (wordle.some(v => v !== v.toLowerCase())) throw new TypeError("Words must be lowercase");
  if (wordle.some(v => v.length !== 5)) throw new TypeError("Leaf-utils: Words cannot exceed 5 in length");

  
    async function sendMessage(content) {
        if (options.slash_command) return options.message.editReply(content);
        else return options.message.channel.send(content);
    }

    if (options.slash_command) {
        if (!options.message.deferred) await options.message.deferReply();
        options.message.author = options.message.user;
    }

    function createEmbed(win, word) {
        const embed = new MessageEmbed()
            .setColor(options.embed.color)
            .setImage("attachment://wordle.png");
        if (win === true) {
            embed.setDescription(options.winMessage);
        } else if (win === false) {
            embed.setDescription(
                options.loseMessage.replace(
                    "{{word}}",
                    `${word.charAt(0).toUpperCase() + word.slice(1)}`
                )
            );
        } else {
            embed.setTitle(options.embed.title);
        }
        return embed;
    }

    function createCanvas(guesses) {
        const canvas = Canvas.createCanvas(1000, 600);
        const context = canvas.getContext("2d");
        let word = 0;
        for (j = 0; j < canvas.height; j += canvas.height / 6) {
            let letter = 0;
            for (i = 0; i < canvas.width / 2; i += canvas.width / 10) {
                context.strokeStyle = "#999999";
                context.lineWidth = 3;
                context.beginPath();
                context.arc(
                    i + offset + radius,
                    j + offset + radius,
                    radius,
                    (3 * Math.PI) / 2,
                    Math.PI,
                    true
                );
                context.arc(
                    i + offset + radius,
                    j + (canvas.height - 10) / 6 - radius,
                    radius,
                    Math.PI,
                    Math.PI / 2,
                    true
                );
                context.arc(
                    i + canvas.width / 10 - radius,
                    j + (canvas.height - 10) / 6 - radius,
                    radius,
                    Math.PI / 2,
                    0,
                    true
                );
                context.arc(
                    i + canvas.width / 10 - radius,
                    j + offset + radius,
                    radius,
                    0,
                    (3 * Math.PI) / 2,
                    true
                );
                context.closePath();
                context.stroke();
                if (guesses[word] && guesses[word][letter]) {
                    context.font = "bold 60px Sans";
                    context.fillStyle = guesses[word][letter].color;
                    context.fill();
                    context.fillStyle = "white";
                    const length = context.measureText(
                        guesses[word][letter].letter
                    ).width;
                    context.fillText(
                        guesses[word][letter].letter,
                        i +
                            offset +
                            (canvas.width / 10 - offset) / 2 -
                            length / 2,
                        j + offset + (canvas.height / 6 - offset) / 2 + 18
                    );
                }
                letter++;
            }
            word++;
        }
        context.drawImage(
            keyboardCanvas(guesses),
            canvas.width / 2 + 25,
            canvas.height / 2 - 175 / 2,
            450,
            157.5
        );
        return canvas;
    }

    function keyboardCanvas(guesses) {
        const map = new Map();
        guesses.forEach((word) => {
            word.forEach((letter) => {
                if (letter.color == green) {
                    map.set(letter.letter, letter.color);
                } else if (letter.letter == yellow) {
                    if (map.get(letter.letter) == gray)
                        map.set(letter.letter, letter.color);
                } else {
                    if (
                        map.get(letter.letter) != green &&
                        map.get(letter.letter) != yellow
                    )
                        map.set(letter.letter, letter.color);
                }
            });
        });
        const canvas = Canvas.createCanvas(1000, 350);
        const context = canvas.getContext("2d");
        let count = 0;
        for (j = 0; j < canvas.height; j += canvas.height / 3) {
            const rowOffset = ((canvas.width / 10) * count) / 2;
            let arrayCount = 0;
            for (
                i = 0;
                i < (canvas.width / 10) * (10 - count);
                i += canvas.width / 10
            ) {
                if (count == 2 && arrayCount == 7) break;
                context.beginPath();
                context.arc(
                    i + radius + rowOffset + offset2,
                    j + radius + offset2,
                    radius,
                    Math.PI,
                    (3 * Math.PI) / 2
                );
                context.arc(
                    i + canvas.width / 10 - radius + rowOffset - offset2,
                    j + radius + offset2,
                    radius,
                    (3 * Math.PI) / 2,
                    0
                );
                context.arc(
                    i + canvas.width / 10 - radius + rowOffset - offset2,
                    j + canvas.height / 3 - radius - offset2,
                    radius,
                    0,
                    Math.PI / 2
                );
                context.arc(
                    i + radius + rowOffset + offset2,
                    j + canvas.height / 3 - radius - offset2,
                    radius,
                    Math.PI / 2,
                    Math.PI
                );
                context.closePath();
                context.fillStyle =
                    map.get(rows[count][arrayCount]) || "#222222";
                context.fill();
                context.fillStyle = "#ffffff";
                context.font = "bold 60px Sans";
                const width = context.measureText(
                    rows[count][arrayCount]
                ).width;
                context.fillText(
                    rows[count][arrayCount],
                    i +
                        offset2 +
                        (canvas.width / 10 - offset2) / 2 -
                        width / 2 +
                        (count * canvas.width) / 20 -
                        3,
                    j + offset2 + (canvas.height / 3 - offset2) / 2 + 16
                );
                arrayCount++;
            }
            count++;
        }
        return canvas;
    }

    async function collect(word) {
        let state;
        const filter = (m) => {
            m.content = m.content.toLowerCase();
            if (m.author.id != options.message.author.id) return false;
            if (m.content.length != 5) {
                (async () => {
                    const reply = await m.reply({
                        content: options.shortMessage,
                        allowedMentions: { repliedUser: false },
                    });
                    setTimeout(() => {
                        reply.delete();
                    }, 5000);
                })();
                return false;
            }
            if (!wordle.includes(m.content)) {
                (async () => {
                    const reply = await m.reply({
                        content: options.invalidMessage,
                        allowedMentions: { repliedUser: false },
                    });
                    setTimeout(() => {
                        if (m.channel.type != "DM") {
                            m.delete();
                        }
                        reply.delete();
                    }, 5000);
                })();
                return false;
            }
            return true;
        };
        const guesses = [];
        let channel = options.message.channel;
        if (!channel)
            channel = await options.message.client.users.cache
                .get(options.message.author.id)
                .createDM();
        const collector = await channel.createMessageCollector({
            filter,
            time: options.time,
            max: 6,
        });
        const initialCanvas = createCanvas([]);
        const initialAttachment = new MessageAttachment(
            initialCanvas.toBuffer(),
            "wordle.png"
        );
        const initialEmbed = createEmbed();
        let interact = await sendMessage({
            embeds: [initialEmbed],
            files: [initialAttachment],
            fetchReply: true,
        });

        collector.on("collect", async (m) => {
            m.content = m.content.toLowerCase();
            guesses.push(makeArray(m.content, word));
            let embed;
            if (m.content == word) {
                state = true;
                embed = createEmbed(true);
                collector.stop();
            } else if (collector.collected.size >= 6) {
                state = false;
                embed = createEmbed(false, word);
                collector.stop();
            } else {
                embed = createEmbed();
            }
            const canvas = createCanvas(guesses);
            const attachment = new MessageAttachment(
                canvas.toBuffer(),
                "wordle.png"
            );
            await interact.removeAttachments();
            interact.edit({
                embeds: [embed],
                files: [attachment],
                fetchReply: true,
            });
            if (m.channel.type != "DM") {
                m.delete();
            }
            collector.resetTimer();
        });

        collector.on("end", async (collected, reason) => {
            if (reason == "time") {
                const embed = createEmbed(false, word);
                embed.setTitle(options.timeoutMessage);
                const canvas = createCanvas(guesses);
                const attachment = new MessageAttachment(
                    canvas.toBuffer(),
                    "wordle.png"
                );
                await interact.removeAttachments();
                await interact.edit({
                    embeds: [embed],
                    files: [attachment],
                });
            }
        });
    }

    function makeArray(word, answer) {
        const array = [];
        const letterWord = word.toUpperCase().split("");
        const letterAnswer = answer.toUpperCase().split("");
        for (i = 0; i < 5; i++) {
            const obj = {
                letter: letterWord[i],
            };
            if (letterWord[i] == letterAnswer[i]) {
                obj.color = green;
            } else if (letterAnswer.includes(letterWord[i])) {
                obj.color = yellow;
            } else {
                obj.color = gray;
            }
            array.push(obj);
        }
        return array;
    }

    const word = wordle[Math.floor(Math.random() * wordle.length)];
    collect(word);
};