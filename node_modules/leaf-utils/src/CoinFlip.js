const { MessageEmbed, MessageButton, MessageActionRow } = require("discord.js");
const { disableButtons } = require("../functions");

module.exports = async (options) => {
    if (!options.message)
        throw new TypeError("NO_MESSAGE: Please provide a message arguement");
    if (typeof options.message !== "object")
        throw new TypeError(
            "INVALID_MESSAGE: Invalid Discord Message object was provided."
        );
    if (!options.slash_command) options.slash_command = false;
    if (typeof options.slash_command !== "boolean")
        throw new TypeError(
            "INVALID_COMMAND_TYPE: Slash command must be a boolean."
        );
    if (!options.time) options.time = 300000;
    if (parseInt(options.time) < 30000)
        throw new Error(
            "Leaf-utils: time argument must be greater than 30 Seconds (in ms)"
        );
    if (typeof options.time !== "number")
        throw new TypeError("Leaf-utils: time must be a number.");

    if (!options.embed) options.embed = {};
    if (!options.embed.title) options.embed.title = "Coinflip";
    if (!options.embed.color) options.embed.color = "RANDOM";

    if (!options.buttons) options.buttons = {};
    if (!options.buttons.heads) options.buttons.heads = "Heads";
    if (!options.buttons.tails) options.buttons.tails = "Tails";

    if (!options.colors) options.colors = {};
    if (!options.colors.heads) options.colors.heads = "DANGER";
    if (!options.colors.tails) options.colors.tails = "PRIMARY";

    if (!options.startMessage)
        options.startMessage =
            "The coin is in the air Choose heads or tails below.";
    if (!options.winMessage)
        options.winMessage =
            "GG, <@{{winner}}> The coin landed on **{{result}}**";
    if (!options.ongoingMessage)
        options.ongoingMessage =
            "A game is already runnning in <#{{channel}}>. You cant start a new one";
    if (!options.authorOnly)
        options.authorOnly = "Only <@{{author}}> can use these buttons!";
    if (!options.loseMessage)
        options.loseMessage =
            "<@{{player}}> You lose The coin landed on **{{result}}**";

    // errors
    if (typeof options.embed !== "object")
        throw new TypeError("Leaf-utils: embed must be an object.");
    if (typeof options.embed.title !== "string")
        throw new TypeError("Leaf-utils: embed title must be a string.");
    if (typeof options.buttons.heads !== "string")
        throw new Error("Leaf-utils: Heads button text must be a string.");
    if (typeof options.buttons.tails !== "string")
        throw new Error("Leaf-utils: Tails button text must be a string.");
    if (typeof options.colors !== "object")
        throw new TypeError("Leaf-utils: colors must be an object.");
    if (typeof options.colors.heads !== "string")
        throw new TypeError("Leaf-utils: heads color must be a string.");
    if (typeof options.colors.tails !== "string")
        throw new TypeError("Leaf-utils: tails color must be a string.");
    if (typeof options.startMessage !== "string")
        throw new TypeError("Leaf-utils: startMessage must be a string.");
    if (typeof options.winMessage !== "string")
        throw new TypeError("Leaf-utils: winMessage must be a string.");
    if (typeof options.ongoingMessage !== "string")
        throw new TypeError("Leaf-utils: ongoingMessage must be a string.");
    if (typeof options.authorOnly !== "string")
        throw new TypeError("Leaf-utils: authorOnly must be a string.");
    if (typeof options.loseMessage !== "string")
        throw new TypeError("Leaf-utils: loseMessage must be a string.");

    async function sendMessage(content) {
        if (options.slash_command) return options.message.editReply(content);
        else return options.message.channel.send(content);
    }

    if (options.slash_command) {
        if (!options.message.deferred) await options.message.deferReply();
        options.message.author = options.message.user;
    }

    const choice = ["heads", "tails"];
    const rand = choice[Math.floor(Math.random() * choice.length)];

    const row1 = new MessageActionRow().addComponents(
        new MessageButton()
            .setStyle(options.colors.heads)
            .setLabel(options.buttons.heads)
            .setCustomId("cf1"),
        new MessageButton()
            .setStyle(options.colors.tails)
            .setLabel(options.buttons.tails)
            .setCustomId("cf2")
    );

    const embed = new MessageEmbed()
        .setTitle(options.embed.title)
        .setDescription(options.startMessage)
        .setColor(options.embed.color);

    const msg = await sendMessage({
        embeds: [embed],
        components: [row1],
    });

    const collector = await msg.createMessageComponentCollector({
        componentType: "BUTTON",
        time: options.time,
    });

    collector.on("collect", async (b) => {
        if (b.user.id !== options.message.author.id)
            return b.reply({
                content: options.authorOnly.replace(
                    "{{author}}",
                    options.message.member.id
                ),
                ephemeral: true,
            });

        await b.deferUpdate();

        if (b.customId === "cf1") {
            if (rand === "heads") {
                await b.editReply({
                    embeds: [
                        embed.setDescription(
                            options.winMessage
                                .replace("{{winner}}", b.user.id)
                                .replace("{{result}}", rand)
                        ),
                    ],
                    components: disableButtons(msg.components),
                });
            } else {
                await b.editReply({
                    embeds: [
                        embed.setDescription(
                            options.loseMessage
                                .replace("{{player}}", b.user.id)
                                .replace("{{result}}", rand)
                        ),
                    ],
                    components: disableButtons(msg.components),
                });
            }
        } else if (b.customId === "cf2") {
            if (rand === "tails") {
                await b.editReply({
                    embeds: [
                        embed.setDescription(
                            options.winMessage
                                .replace("{{winner}}", b.user.id)
                                .replace("{{result}}", rand)
                        ),
                    ],
                    components: disableButtons(msg.components),
                });
            } else {
                await b.editReply({
                    embeds: [
                        embed.setDescription(
                            options.loseMessage
                                .replace("{{player}}", b.user.id)
                                .replace("{{result}}", rand)
                        ),
                    ],
                    components: disableButtons(msg.components),
                });
            }
        }
    });

    collector.on("end", async (b, reason) => {
        row1.components[0].setDisabled(true);
        row1.components[1].setDisabled(true);
        if (reason === "time") {
            msg.edit({
                components: [row1],
            });
        }
    });
};
