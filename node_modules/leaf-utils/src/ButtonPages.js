const { MessageButton, MessageActionRow } = require("discord.js");
const { disableButtons } = require("../functions");

module.exports = async (options) => {
    if (!options.message)
        throw new TypeError("NO_MESSAGE: Please provide a message arguement");
    if (typeof options.message !== "object")
        throw new TypeError(
            "INVALID_MESSAGE: Invalid Discord Message object was provided."
        );
    if (!options.slash_command) options.slash_command = false;
    if (typeof options.slash_command !== "boolean")
        throw new TypeError(
            "INVALID_COMMAND_TYPE: Slash command must be a boolean."
        );
    if (!options.time) options.time = 60000;
    if (parseInt(options.time) < 30000)
        throw new Error(
            "Leaf-utils: time argument must be greater than 30 Seconds (in ms)"
        );
    if (typeof options.time !== "number")
        throw new TypeError("Leaf-utils: time must be a number.");

    const pages = options.pages;
    if (!pages)
        throw new TypeError("NO_PAGES: Please provide a page arguement");
    if (!Array.isArray(pages)) throw new Error("Pages must be an array");

    if (!options.back) options.back = {};
    if (!options.back.label) options.back.label = " ";
    if (!options.back.style) options.back.style = "PRIMARY";
    if (!options.back.emoji) options.back.emoji = "⬅️";

    if (!options.home) options.home = {};
    if (!options.home.label) options.home.label = " ";
    if (!options.home.style) options.home.style = "DANGER";
    if (!options.home.emoji) options.home.emoji = "🏠";

    if (!options.next) options.next = {};
    if (!options.next.label) options.next.label = " ";
    if (!options.next.style) options.next.style = "PRIMARY";
    if (!options.next.emoji) options.next.emoji = "➡️";

    if (!options.authorOnly) options.authorOnly = "You can't use these buttons";

    async function sendMessage(content) {
        if (options.slash_command) return options.message.editReply(content);
        else return options.message.channel.send(content);
    }

    if (options.slash_command) {
        if (!options.message.deferred) await options.message.deferReply();
        options.message.author = options.message.user;
    }

    if (pages.length === 1) {
        const page = await sendMessage({
            embeds: pages,
            components: [],
            fetchReply: true,
        });

        return page;
    }

    const prev = new MessageButton()
        .setCustomId("prev")
        .setLabel(options.back.label)
        .setEmoji(options.back.emoji)
        .setStyle(options.back.style)
        .setDisabled(true);

    const home = new MessageButton()
        .setCustomId("home")
        .setLabel(options.home.label)
        .setEmoji(options.home.emoji)
        .setStyle(options.home.style)
        .setDisabled(true);

    const next = new MessageButton()
        .setCustomId("next")
        .setLabel(options.next.label)
        .setEmoji(options.next.emoji)
        .setStyle(options.next.style);

    const buttonRow = new MessageActionRow().addComponents(prev, home, next);
    let currentPageIndex = 0;

    const currentPage = await sendMessage({
        embeds: [pages[currentPageIndex]],
        components: [buttonRow],
        fetchReply: true,
    });

    const collector = await currentPage.createMessageComponentCollector({
        componentType: "BUTTON",
        time: options.time,
    });

    collector.on("collect", async (i) => {
        if (i.user.id !== options.message.author.id)
            return i.reply({
                content: options.authorOnly.replace(
                    "{{author}}",
                    options.message.member.id
                ),
                ephemeral: true,
            });

        await i.deferUpdate();

        if (i.customId === "prev") {
            if (currentPageIndex > 0) currentPageIndex--;
        } else if (i.customId === "home") {
            currentPageIndex = 0;
        } else if (i.customId === "next") {
            if (currentPageIndex < pages.length - 1) currentPageIndex++;
        }

        if (currentPageIndex === 0) prev.setDisabled(true);
        else if (prev.disabled) prev.setDisabled(false);

        if (currentPageIndex === 0) home.setDisabled(true);
        else if (home.disabled) home.setDisabled(false);

        if (currentPageIndex === pages.length - 1) next.setDisabled(true);
        else if (next.disabled) next.setDisabled(false);

        await currentPage.edit({
            embeds: [pages[currentPageIndex]],
            components: [buttonRow],
        });

        collector.resetTimer();
    });

    collector.on("end", async (i, reason) => {
        try {
            await currentPage.edit({
                embeds: [pages[currentPageIndex]],
                components: disableButtons(currentPage.components),
            });
        } catch (err) {
            if (err.code === 10008) return;
        }
    });
    return currentPage;
};
